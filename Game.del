macro eventPlayer : EventPlayer();
macro eventPlayerTeam : TeamOf(EventPlayer());
macro hostPlayer : HostPlayer();
macro attacker : Attacker();
macro victim : Victim();

globalvar define line = 0;
globalvar Barrier[] Barriers = [];
public macro barrierSize: 2.2;

playervar define numberOfBarriers = 0;
playervar define didDoDamage = false;
playervar define timeSinceAlive = 0;

rule: "stuff"
{
    CreateHudText(FilteredArray(AllPlayers(Team.Team1), line >= 0), line, null, null, Location.Top, 1, Color.Blue, Color.White, Color.White, StringRev.VisibleToAndString, Spectators.DefaultVisibility);
    CreateHudText(FilteredArray(AllPlayers(Team.Team1), line < 0), line, null, null, Location.Top, 1, Color.Red, Color.White, Color.White, StringRev.VisibleToAndString, Spectators.DefaultVisibility);
    CreateHudText(FilteredArray(AllPlayers(Team.Team2), line <= 0), -line, null, null, Location.Top, 1, Color.Blue, Color.White, Color.White, StringRev.VisibleToAndString, Spectators.DefaultVisibility);
    CreateHudText(FilteredArray(AllPlayers(Team.Team2), line > 0), -line, null, null, Location.Top, 1, Color.Red, Color.White, Color.White, StringRev.VisibleToAndString, Spectators.DefaultVisibility);

    CreateBeamEffect(FilteredArray(AllPlayers(), line == 0), BeamType.GoodBeam, Vector(-30, 0.2, line), Vector(30, 0.2, line), Color.White, EffectRev.VisibleToPositionAndRadius);
    CreateBeamEffect(FilteredArray(AllPlayers(), line > 0), BeamType.GoodBeam, Vector(-30, 0.2, line), Vector(30, 0.2, line), Color.Team1, EffectRev.VisibleToPositionAndRadius);
    CreateBeamEffect(FilteredArray(AllPlayers(), line < 0), BeamType.GoodBeam, Vector(-30, 0.2, line), Vector(30, 0.2, line), Color.Team2, EffectRev.VisibleToPositionAndRadius);
}

rule: "Player Setup"
Event.OngoingPlayer
{
    CreateHudText(EventPlayer(), IconString(Icon.Halo), "Number of barriers", numberOfBarriers, Location.Top, 2, Color.Blue, Color.SkyBlue, Color.Orange);
    DamageMod(0);
    DamageMod(1);
    DamageMod(2);
    DamageMod(3);
    DamageMod(4);
    DamageMod(5);
}

method DamageMod(ref define slot)
{
    StartDamageModification(
        PlayersInSlot(slot, OppositeTeamOf(eventPlayerTeam)),
        eventPlayer,
        IsTrueForAny(Barriers, DoesLineIntersectSphere(
            EyePosition(eventPlayer),
            !IsUsingUltimate() ? FacingDirectionOf(eventPlayer) : DirectionTowards(EyePosition(eventPlayer), EyePosition(PlayersInSlot(slot, OppositeTeamOf(eventPlayerTeam)))),
            (<Barrier>ArrayElement()).Position,
            barrierSize
        )) ? 0 : 100,
        DamageModificationRev.ReceiversDamagersAndDamagePercent
    );
}

rule: "Player Setup Alive"
Event.OngoingPlayer
if (IsAlive())
if (HasSpawned())
{
    RespawnPlayer(eventPlayer);
}

method RespawnPlayer(define player)
{
    Teleport(player, Vector(RandomReal(-19, 20), 0, Max(-19, Min(19, line - (TeamOf(player) == Team.Team1 ? 10 : -10)))))
    player.timeSinceAlive = TotalTimeElapsed();
}

rule: "dum"
if (IsButtonHeld(HostPlayer(), Button.Melee))
{
    CreateDummyBot(Hero.Mccree, OppositeTeamOf(TeamOf(HostPlayer())), -1, PositionOf(HostPlayer()), FacingDirectionOf(HostPlayer()));
}

rule: "On Kill"
Event.OnFinalBlow
{
    numberOfBarriers++;
}

rule: "T1: Death"
Event.OnDeath
Team.Team1
{
    line--;
}
rule: "T2: Death"
Event.OnDeath
Team.Team2
{
    line++;
}

rule: "Did Do Damage"
Event.OnDamageDealt
{
    didDoDamage = true;
}

rule: "Shoot"
Event.OngoingPlayer
if (IsFiringPrimary() || didDoDamage)
{
    if (didDoDamage)
    {
        didDoDamage = false;
        Abort();
    }

    define hitPos = RayCastHitPosition(
        EyePosition(),
        Destination(EyePosition(), FacingDirectionOf(), 300),
        AllPlayers(OppositeTeamOf(TeamOf())),
        null,
        false
    );

    Barrier intersect = FilteredArray(
        SortedArray(
            Barriers,
            DistanceBetween(PositionOf(), (<Barrier>ArrayElement()).Position)
        ),
        (DistanceBetween(PositionOf(), (<Barrier>ArrayElement()).Position) < DistanceBetween(PositionOf(), hitPos)) &&
        DoesLineIntersectSphere(
            EyePosition(),
            FacingDirectionOf(),
            (<Barrier>ArrayElement()).Position,
            barrierSize
        )
    )[0];

    if (intersect != null)
        intersect.Damage(eventPlayer);
}

rule: "Stun heal"
Event.OnDamageDealt
if (EventDamage() == 25)
{
    Heal(eventPlayer, null, 100);
}

rule: "Create barrier"
Event.OngoingPlayer
if (IsButtonHeld(EventPlayer(), Button.Interact))
if (numberOfBarriers > 0)
{
    numberOfBarriers--;
    ModifyVariable(Barriers, Operation.AppendToArray, new Barrier(EyePosition() + FacingDirectionOf() * 3, TeamOf() == Team.Team1));
}

class Barrier
{
    public define Position;
    public define BarrierTeam;
    public define health = 6;
    public define effectID;
    public define healthEffect;

    public Batter(ref define pos, ref define team)
    {
        Position = pos;
        BarrierTeam = team;

        if (BarrierTeam)
            CreateEffect(AllPlayers(), Effect.Sphere, Color.Team1, Position, root.barrierSize, EffectRev.VisibleTo);
        else
            CreateEffect(AllPlayers(), Effect.Sphere, Color.Team2, Position, root.barrierSize, EffectRev.VisibleTo);
        effectID = LastCreatedEntity();
        HealthEffect();
    }

    public method Damage(ref define damager)
    {
        if ((TeamOf(damager) == Team.Team1) == BarrierTeam) return;
        health--;

        if (health == 0)
        {
            DestroyEffect(effectID);
            DestroyEffect(healthEffect);
            if (BarrierTeam)
                PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Team1, Position, 5);
            else
                PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Team2, Position, 5);
            PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, Color.Team2, Position, 100);

            ModifyVariable(root.Barriers, Operation.RemoveFromArrayByValue, this);
        }
        else
        {
            PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.Team2, Position, 100);
            HealthEffect();
        }
    }

    public method HealthEffect()
    {
        DestroyEffect(healthEffect);
        CreateEffect(AllPlayers(), Effect.Sphere, Color.Green, Position, root.barrierSize*(1/6)*health, EffectRev.VisibleTo);
        healthEffect = LastCreatedEntity();
    }

    public method Destroy()
    {
        DestroyEffect(effectID);
        DestroyEffect(healthEffect);
        ModifyVariable(root.Barriers, Operation.RemoveFromArrayByValue, this);
    }
}

macro touchingBarrier(Barrier barrier, define player): DistanceBetween(barrier.Position, PositionOf(player)) < root.barrierSize;
macro touchingAnyBarrier(define player): IsTrueForAny(Barriers, touchingBarrier(<Barrier>ArrayElement(), player));
macro firstTouchingBarrier(define player): FilteredArray(Barriers, touchingBarrier(<Barrier>ArrayElement(), player))[0];

rule: "Touching barrier"
Event.OngoingPlayer
if (touchingAnyBarrier(eventPlayer))
{
    Barrier touching = firstTouchingBarrier(eventPlayer);
    ApplyImpulse(eventPlayer, DirectionTowards(touching.Position * Vector(1, 0, 1), PositionOf() * Vector(1, 0, 1)) + Vector(0, 1, 0), 1, Relative.ToWorld, ContraryMotion.Incorporate);
    MinWait();
    LoopIfConditionIsTrue();
}

globalvar Empty empty = new Empty();
class Empty {}

rule: "Wrong side"
Event.OngoingPlayer
Team.Team1
if (ZOf(PositionOf(EventPlayer())) > line)
if (TotalTimeElapsed() - timeSinceAlive > 2)
{
    ApplyImpulse(EventPlayer(), Vector(0, 1, -1), 10, Relative.ToWorld, ContraryMotion.Cancel);
    MinWait();
    LoopIfConditionIsTrue();
}

rule: "Wrong side"
Event.OngoingPlayer
Team.Team2
if (ZOf(PositionOf(EventPlayer())) < line)
if (TotalTimeElapsed() - timeSinceAlive > 0.3)
{
    ApplyImpulse(EventPlayer(), Vector(0, 1, 1), 10, Relative.ToWorld, ContraryMotion.Cancel);
    MinWait();
    LoopIfConditionIsTrue();
}

disabled rule: "Damage counter"
Event.OnDamageDealt
{
    SmallMessage(eventPlayer, EventDamage());
}

rule: "Team 1 wins"
if (AbsoluteValue(line) >= 23)
{
    define losingTeam;
    define winningTeam;

    if (line > 0)
    {
        winningTeam = Team.Team1;
        losingTeam = Team.Team2;
    }
    else
    {
        winningTeam = Team.Team2;
        losingTeam = Team.Team1;
    }

    BigMessage(AllPlayers(winningTeam), "You win!");
    BigMessage(AllPlayers(losingTeam), "You lose!");

    line = 0;
    AllPlayers().numberOfBarriers = 0;

    while (CountOf(Barriers) > 0)
    {
        Barriers[0].Destroy();
        MinWait();
    }

    foreach (define player in AllPlayers())
        RespawnPlayer(player);
}