//import "!Debug Tools.del";

macro eventPlayer : EventPlayer();
macro eventPlayerTeam : TeamOf(EventPlayer());
macro hostPlayer : HostPlayer();
macro attacker : Attacker();
macro victim : Victim();

public macro barrierSize: 2.2;
public macro ultChargeOnHit: 4;
public macro ultChargeOnCrit: 8;

globalvar define line = 0;
globalvar Barrier[] Barriers = [];

playervar define numberOfBarriers = 0;
playervar define timeSinceAlive = 0;

rule: "stuff"
{
    CreateHudText(FilteredArray(AllPlayers(Team.Team1), line >= 0), line, null, null, Location.Top, 1, Color.Blue, Color.White, Color.White, StringRev.VisibleToAndString, Spectators.DefaultVisibility);
    CreateHudText(FilteredArray(AllPlayers(Team.Team1), line < 0), line, null, null, Location.Top, 1, Color.Red, Color.White, Color.White, StringRev.VisibleToAndString, Spectators.DefaultVisibility);
    CreateHudText(FilteredArray(AllPlayers(Team.Team2), line <= 0), -line, null, null, Location.Top, 1, Color.Blue, Color.White, Color.White, StringRev.VisibleToAndString, Spectators.DefaultVisibility);
    CreateHudText(FilteredArray(AllPlayers(Team.Team2), line > 0), -line, null, null, Location.Top, 1, Color.Red, Color.White, Color.White, StringRev.VisibleToAndString, Spectators.DefaultVisibility);
    
    CreateHudText(AllPlayers(), null, null, "Press interact to create a barrier.", Location.Left, 0, Color.Red, Color.White, Color.Orange, StringRev.VisibleToAndString, Spectators.DefaultVisibility);
    CreateHudText(AllPlayers(), null, null, "Each kill moves the line towards the enemy side. Push them to the cliff to win.", Location.Left, 1, Color.Red, Color.White, Color.Blue, StringRev.VisibleToAndString, Spectators.DefaultVisibility);

    CreateBeamEffect(FilteredArray(AllPlayers(), line == 0), BeamType.GoodBeam, Vector(-30, 0.2, line), Vector(30, 0.2, line), Color.White, EffectRev.VisibleToPositionAndRadius);
    CreateBeamEffect(FilteredArray(AllPlayers(), line > 0), BeamType.GoodBeam, Vector(-30, 0.2, line), Vector(30, 0.2, line), Color.Team1, EffectRev.VisibleToPositionAndRadius);
    CreateBeamEffect(FilteredArray(AllPlayers(), line < 0), BeamType.GoodBeam, Vector(-30, 0.2, line), Vector(30, 0.2, line), Color.Team2, EffectRev.VisibleToPositionAndRadius);
}

rule: "Player Setup"
Event.OngoingPlayer
{
    CreateHudText(EventPlayer(), IconString(Icon.Halo), "Number of barriers", numberOfBarriers, Location.Top, 2, Color.Blue, Color.SkyBlue, Color.Orange);
}

rule: "Player Setup Alive"
Event.OngoingPlayer
if (IsAlive())
if (HasSpawned())
{
    RespawnPlayer(eventPlayer);
    SetStatus(eventPlayer, null, Status.Unkillable, 9999);
}

method RespawnPlayer(define player)
{
    Teleport(player, Vector(RandomReal(-19, 20), 0, Max(-19, Min(19, line - (TeamOf(player) == Team.Team1 ? 10 : -10)))))
    player.timeSinceAlive = TotalTimeElapsed();
}

disabled rule: "dum"
if (IsButtonHeld(HostPlayer(), Button.Melee))
{
    CreateDummyBot(Hero.Mccree, (NumberOfPlayers(Team.Team1) < 6) ? Team.Team1 : Team.Team2, -1, PositionOf(HostPlayer()), FacingDirectionOf(HostPlayer()));
}

rule: "On Kill"
Event.OnFinalBlow
{
    numberOfBarriers++;
}

rule: "T1: Death"
Event.OnDeath
Team.Team1
{
    line--;
}
rule: "T2: Death"
Event.OnDeath
Team.Team2
{
    line++;
}


rule: "Did Do Damage"
Event.OnDamageDealt
{
    async! Damage();
}

rule: "Shoot"
Event.OngoingPlayer
if (IsFiringPrimary())
{
    async! Damage();
}

method Damage() "Damage Check"
{
    define hitPos;
    
    if (victim != null) hitPos = PositionOf(victim)
    else hitPos = RayCastHitPosition(
        EyePosition(),
        Destination(EyePosition(), FacingDirectionOf(), 300),
        AllPlayers(OppositeTeamOf(TeamOf())),
        null,
        false
    );

    Barrier intersect = FilteredArray(
        SortedArray(
            Barriers,
            DistanceBetween(PositionOf(), (<Barrier>ArrayElement()).Position)
        ),
        (DistanceBetween(PositionOf(), (<Barrier>ArrayElement()).Position) < DistanceBetween(PositionOf(), hitPos)) &&
        DoesLineIntersectSphere(
            EyePosition(),
            FacingDirectionOf(),
            (<Barrier>ArrayElement()).Position,
            barrierSize
        )
    )[0];

    if (intersect != null)
    {
        intersect.Damage(eventPlayer);
        Heal(victim, null, EventDamage())
    }
    else if (victim != null)
    {
        // Give ultimate charge.
        if (!IsUsingUltimate())
        {
            // Crit
           // if (EventWasCriticalHit())
             //   SetUltimateCharge(eventPlayer, UltimateChargePercent(eventPlayer) + ultChargeOnCrit);
            // Normal
            //else
            SetUltimateCharge(eventPlayer, UltimateChargePercent(eventPlayer) + (4/80)*EventDamage());
        }

        if (Health(victim) == 1)
        {
            ClearStatus(victim, Status.Unkillable);
            Kill(victim, eventPlayer);
        }
    }
}

rule: "Stun heal"
Event.OnDamageDealt
if (EventDamage() == 25)
{
    Heal(eventPlayer, eventPlayer, 75);
}

rule: "Create barrier"
Event.OngoingPlayer
if (IsButtonHeld(EventPlayer(), Button.Interact))
if (numberOfBarriers > 0)
{
    numberOfBarriers--;
    ModifyVariable(Barriers, Operation.AppendToArray, new Barrier(EyePosition() + FacingDirectionOf() * 3, TeamOf() == Team.Team1));
}

class Barrier
{
    public define Position;
    public define BarrierTeam;
    public define health = 6;
    public define effectID;
    public define healthEffect;

    public Batter(ref define pos, ref define team)
    {
        Position = pos;
        BarrierTeam = team;

        if (BarrierTeam)
            CreateEffect(AllPlayers(), Effect.Sphere, Color.Team1, Position, root.barrierSize, EffectRev.VisibleTo);
        else
            CreateEffect(AllPlayers(), Effect.Sphere, Color.Team2, Position, root.barrierSize, EffectRev.VisibleTo);
        effectID = LastCreatedEntity();
        HealthEffect();
    }

    public method Damage(ref define damager)
    {
        if ((TeamOf(damager) == Team.Team1) == BarrierTeam) return;
        health--;

        if (health == 0)
        {
            DestroyEffect(effectID);
            DestroyEffect(healthEffect);
            if (BarrierTeam)
                PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Team1, Position, 5);
            else
                PlayEffect(AllPlayers(), PlayEffect.RingExplosion, Color.Team2, Position, 5);
            PlayEffect(AllPlayers(), PlayEffect.RingExplosionSound, Color.Team2, Position, 100);

            ModifyVariable(root.Barriers, Operation.RemoveFromArrayByValue, this);
        }
        else
        {
            PlayEffect(AllPlayers(), PlayEffect.ExplosionSound, Color.Team2, Position, 100);
            HealthEffect();
        }
    }

    public method HealthEffect()
    {
        DestroyEffect(healthEffect);
        CreateEffect(AllPlayers(), Effect.Sphere, Color.Green, Position, root.barrierSize*(1/6)*health, EffectRev.VisibleTo);
        healthEffect = LastCreatedEntity();
    }

    public method Destroy()
    {
        DestroyEffect(effectID);
        DestroyEffect(healthEffect);
        ModifyVariable(root.Barriers, Operation.RemoveFromArrayByValue, this);
    }
}

macro touchingBarrier(Barrier barrier, define player): DistanceBetween(barrier.Position, PositionOf(player)) < root.barrierSize;
macro touchingAnyBarrier(define player): IsTrueForAny(Barriers, touchingBarrier(<Barrier>ArrayElement(), player));
macro firstTouchingBarrier(define player): FilteredArray(Barriers, touchingBarrier(<Barrier>ArrayElement(), player))[0];

disabled rule: "Touching barrier"
Event.OngoingPlayer
if (touchingAnyBarrier(eventPlayer))
{
    Barrier touching = firstTouchingBarrier(eventPlayer);
    ApplyImpulse(eventPlayer, DirectionTowards(touching.Position * Vector(1, 0, 1), PositionOf() * Vector(1, 0, 1)) + Vector(0, 1, 0), 1, Relative.ToWorld, ContraryMotion.Incorporate);
    MinWait();
    LoopIfConditionIsTrue();
}

globalvar Empty empty = new Empty();
class Empty {}

rule: "Wrong side"
Event.OngoingPlayer
Team.Team1
if (ZOf(PositionOf(EventPlayer())) > line)
if (TotalTimeElapsed() - timeSinceAlive > 2)
{
    ApplyImpulse(EventPlayer(), Vector(0, 1, -1), 10, Relative.ToWorld, ContraryMotion.Cancel);
    MinWait();
    LoopIfConditionIsTrue();
}

rule: "Wrong side"
Event.OngoingPlayer
Team.Team2
if (ZOf(PositionOf(EventPlayer())) < line)
if (TotalTimeElapsed() - timeSinceAlive > 0.3)
{
    ApplyImpulse(EventPlayer(), Vector(0, 1, 1), 10, Relative.ToWorld, ContraryMotion.Cancel);
    MinWait();
    LoopIfConditionIsTrue();
}

disabled rule: "Damage counter"
Event.OnDamageDealt
{
    SmallMessage(eventPlayer, EventDamage());
}

rule: "Win"
if (AbsoluteValue(line) >= 20)
{
    define losingTeam;
    define winningTeam;

    if (line > 0)
    {
        winningTeam = Team.Team1;
        losingTeam = Team.Team2;
    }
    else
    {
        winningTeam = Team.Team2;
        losingTeam = Team.Team1;
    }

    BigMessage(AllPlayers(winningTeam), "You win!");
    BigMessage(AllPlayers(losingTeam), "You lose!");

    line = 0;
    AllPlayers().numberOfBarriers = 0;

    while (CountOf(Barriers) > 0)
    {
        Barriers[0].Destroy();
        MinWait();
    }

    foreach (define player in AllPlayers())
    {
        Respawn(player);
        MinWait();
        RespawnPlayer(player);
        MinWait();
    }
}